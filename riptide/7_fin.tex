\subsection{Control flow in the NoC}
\label{sec:fin}

Control-flow operators are simple to implement (often a single
multiplexer), but there are many of them.
%
Mapping each to a PE wastes energy and area, and can make mapping
to the CGRA infeasible.
%
Among our ten benchmarks,
46\% of operations are control flow,
and eight benchmarks do not map if each control-flow operator requires a dedicated PE.

We observe that much of the logic required to implement control flow is already
plentiful in the NoC.
%
Each NoC switch is a crossbar that can be re-purposed to mux values for
control.
%
Thus, to implement each control-flow operator, \riptide manipulates a switch's
routing and ready/valid signals to provide the desired functionality.

\riptide's router microarchitecture is shown in \autoref{fig:riptide:arch:router}.
% 
The router shares routing configuration and its data and valid crossbars with
the baseline NoC.
%
\riptide adds a control-flow module (CFM) at a configurable number of output ports (in our case, two output ports).
% 
The CFM determines when to send data to the output port and
manipulates inputs to the data switch to select which data is sent.

%% \figRipTideFilter

%% \paragraph{Sketch of the CF module.}
%% %
%% The CF module (\autoref{fig:riptide:filter}) takes three inputs: {\tt A}, {\tt B}, and decider {\tt D} from the switch and produces {\tt out}.
%% %
%% The CF module implements eight operations: no connection, direct connection, carry, invariant, steer, order, merge, and select.
%% % 
%% The actual implementation of the CF module reuses existing switch hardware so does not directly interact with data values {\tt A} and {\tt B}, but the simple mental model does capture the high-level operation.\nzb{Huh?}

\paragraph{Control-flow module.}
%
The CFM takes eight inputs and produces five outputs that control router
configuration and dataflow through the network.
% 
The inputs are:
\begin{compactitem}

\item {\tt cfg}: configuration of the CFM (i.e., opcode);

\item {\tt A\_valid}, {\tt B\_valid}, {\tt D\_valid}: whether inputs are valid;

\item {\tt D}: value of the decider;

\item {\tt A\_cxn} and {\tt B\_cxn}: input ports for {\tt A} and {\tt B}; and

\item {\tt noc\_ready}: backpressure signal from the output port.
  
\end{compactitem}
%
From this, the CFM produces outputs:
\begin{compactitem}
  
\item {\tt A\_ready}, {\tt B\_ready}, and {\tt D\_ready}: upstream
  backpressure signals that allow the CFM to block upstream
  producers until all signals required are valid;

\item {\tt noc\_valid}: the valid signal for the CF's output; and

\item {\tt cxn}: which port ({\tt A\_cxn} or {\tt B\_cxn}) to route
  to the output port on the data switch.
  
\end{compactitem}

\begin{figure}[t]
\begin{subfigure}{\linewidth}
\begin{lstlisting}[style=custompython]
cxn = A_cxn
forever:
    A_ready = D_ready = 0
    if A_valid && D_valid: # wait for A and D
        # if D is true, pass through A;
        # else discard A 
        noc_valid = D
        A_ready = D_ready = noc_ready || !D
        if D: wait for noc_ready
\end{lstlisting}
\caption{Steer (True flavor).}
\label{lst:fin:steer}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{lstlisting}[style=custompython]
forever:
    # begin in Initial state
    if A_valid:
        cxn = A_cxn         # pass through A
        noc_valid = A_valid
        D_ready = A_ready = noc_ready
        B_ready = xxx       # don't care
    wait for noc_ready
    # transition to Block state
    do until D_valid && !D:
        cxn = B_cxn         # pass through B
        noc_valid = B_valid
        D_ready = B_ready = noc_ready
        A_ready = false     # hold A at input
        wait for noc_ready
\end{lstlisting}
\caption{Carry.}
\label{lst:fin:carry}
\end{subfigure}
  \caption{Implementing control flow using NoC control signals.}
  \label{lst:fin}
\end{figure}

\paragraph{Supported operations.}
The CFM can be configured for routing or for the control operators in
\autoref{sec:cf}.
%
Routing, e.g., {\tt out = A}, is simple: just set {\tt cxn = A\_cxn}, {\tt
noc\_valid = A\_valid}, and {\tt A\_ready = noc\_valid}.

Other operators are more involved, but each requires only a
small state machine.
%
\autoref{lst:fin} is pseudocode for steer and carry operators
(\autoref{sec:cf}).
%
A steer forwards {\tt A} if {\tt D} is true; otherwise,
it discards {\tt A}.
%
To implement steer, the CFM waits for {\tt A} and {\tt D}
to be valid.
%
If {\tt D} is true, then {\tt noc\_valid} is raised, and the {\tt
  noc\_ready} signal propagates upstream to {\tt A} and {\tt D}
and the CFM waits for {\tt noc\_ready}, i.e., for the value to be consumed.
%
If {\tt D} is false, then {\tt noc\_valid} is kept low, and
{\tt A\_ready} and {\tt D\_ready} are raised to discard these
tokens.

Carry is more complicated.
%
Carry begins in {\em Initial} state, waiting for a valid {\tt A}
token.
%
It forwards the token and transitions to {\em Blocked} state, where
it forwards {\tt B} until it sees a false {\tt D} token.
%
See the pseudocode in \autoref{lst:fin:carry} for details.

\paragraph{Control flow in the NoC adds small hardware overheads.}
%
Implementing control flow in the NoC is far more energy- and
area- efficient than in a PE, saving an estimated 40\% energy and 22\% area v. CGRA with all CF operations mapped to PEs (All PEs in~\autoref{fig:riptide:eval:fin}).
%
The CFM deals only with narrow control signals and the 1b decider
value {\tt D}.
%
It does not need to touch full data signals at all; these are
left to the pre-existing data switch.
%
Importantly, this means that the CFM adds no data buffers.
%
Instead, the CFM simply raises the {\tt *\_ready} signals to park
values in the upstream output channels until they are no longer
needed.

By contrast, implementing control flow in a PE requires full
data-width muxes and, if an entire PE is dedicated to control, an
output channel to hold the results.
%
Nevertheless, \riptide is sometimes forced to allocate a PE for control
flow.
%
Specifically, if a control-flow operator takes a constant or
software-supplied value that is not -1, 0, or 1, it currently requires \textmu core support.
% \nzb{This section is missing numbers to emphasize the low area cost, especially v.\ alternatives.}

%% \begin{compactitem}

%% \item \emph{No connection:} The CF module is disabled.

%% \item \emph{Direct connection:} Basic routing behavior, {\tt Out = A}.
%%   This is achieved by setting {\tt cxn = A\_cxn}, {\tt A\_ready = noc\_ready}, and {\tt noc\_valid = A\_valid}.

%% \item \emph{Steer:} 
  
%% \end{compactitem}
%% \paragraph{No connection} Program disables the CF module.

%% \paragraph{Direct connection} {\tt Out = A}.

%% \paragraph{Steer} CF module waits for {\tt D\_valid} and {\tt A\_valid} and depending on configuration (True or False steer) and {\tt D} chooses whether to send data on the output port (raising or lowering {\tt noc\_ov}).

%% \paragraph{Carry} CF module implements the state machine from \autoref{fig:riptide:cf:gates}. 
%% % 
%% The CF module starts in the initial state, waiting for {\tt A\_valid} and when valid sets {\tt Out = A}. 
%% % 
%% The module then transitions to the block state, waiting for {\tt D\_valid} and depending on {\tt D}, {\tt B\_valid}. 
%% % 
%% {\tt B} represents the loop-carried dependency. 
%% % 
%% If {\tt D} matches the predicate to run the loop, the CF module waits for {\tt B\_valid} and sets {\tt cxn} to {\tt B\_cxn}.
%% % 
%% This reconfigures the data switch to select data from the input port corresponding to {\tt B}, not {\tt A}.
%% %
%% If {\tt D} does not match the loop predicate, the loop is finished running, the module consumes {\tt D} (lowers {\tt D\_pr}), and transitions back to the initial state.
%% % 
%% While the CF module is in the block state, if data arrives at {\tt A}, then the CF module raises {\tt A\_pr} to block upstream producers so the value is held until the module transitions back to the initial state.

%% \paragraph{Invariant} The CF module implements invariants similarly to carries (an invariant can be implemented with a carry with a self-backedge).
%% % 
%% The CF module starts out in the initial state waiting for {\tt A\_valid}.
%% % 
%% Then once valid transitions to the block state.
%% % 
%% Unlike the implementation of carry, the CF module does not consume {\tt A}, but rather raises {\tt A\_pr} to maintain the value while the loop runs.
%% % 
%% Once in the block state, the module waits for {\tt D\_valid}; if {\tt D} matches the loop predicate, the module raises {\tt noc\_ov}, setting {\tt Out} to the held {\tt A}; otherwise, the module consumes {\tt D} (lowers {\tt D\_pr}), consumes {\tt A} (lowers {\tt A\_pr}), and transitions back to the initial state.

%% \paragraph{Select} The CF module waits for {\tt D\_valid}, {\tt A\_valid}, and {\tt B\_valid}.
%% % 
%% Then depending on {\tt D}, sets {\tt cxn} to {\tt A\_cxn} (if true) or {\tt B\_cxn} (if false).
%% % 
%% This reconfigures the data switch to choose between {\tt A} and {\tt B} depending on {\tt D}.

%% \paragraph{Order} The order operation is similar to select, but instead of waiting for all three inputs, waits for {\tt D} as well as the input that matches {\tt D}; if {\tt D} is true, wait for {\tt A}, otherwise wait for {\tt B}.

%% \paragraph{Merge} CF module waits for both {\tt A\_valid} and {\tt B\_valid}.
%% % 
%% As soon as both are valid, raises {\tt noc\_ov}.
%% % 
%% Merge is used for synchronization so the outgoing data does not matter, just the outgoing valid signal.

\paragraph{Buffering of decider values.}
The CFM provides a small amount of buffering for decider values.
% 
This is because loop deciders often have high fanout, which means that the next iteration of a loop is likely blocked by one or more downstream consumers.
% 
To remove this limitation, \riptide provides a small amount of downstream buffering for 1b decider signals, improving performance with minimal impact on area.
%
The CFM uses run-length encoding to buffer up to eight decider values with just 3b of additional state, yielding up to $3.8\times$ performance (on {\tt dmm}) at an area of cost of $<$\,1\%.
