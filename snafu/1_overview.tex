\figSNAFUOverviewFramework
\figSNAFUOverviewExecute
\section{Overview}
\label{snafu:overview}

\snafuframe is a framework for generating energy-minimal, ULP CGRAs
and compiling applications to run efficiently on them.
%
\snafuarch is a complete ULP system featuring a CGRA generated by \snafuframe,
a scalar core, and memory.

\paragraph{\snafuframe is a flexible ULP CGRA generator}
\snafuframe is a general and flexible framework for converting a high-level
description of a CGRA to valid RTL and ultimately to ULP hardware.
% 
\autoref{fig:snafu:overview:framework} shows \snafuframe's workflow.
% 
\snafuframe takes two inputs: a library of processing elements (PEs) and a high-level description of the CGRA topology.
% 
\snafuframe lets designers customize the ULP CGRA
%
via a {\em ``bring your own functional unit''} approach,
defining a generic PE interface that makes it easy to add custom logic to a generated CGRA.

With these inputs, \snafuframe generates complete RTL for the CGRA.
% 
This RTL includes a statically routed, bufferless, multi-hop on-chip network parameterized by the topology description.
% 
It also includes hardware to handle variable-latency timing and asynchronous dataflow firing.
%
Finally, \snafuframe simplifies hardware generation by supporting top-down synthesis,
making it easy to go from a high-level CGRA description to a placed-and-routed ULP design ready for tape out.

\paragraph{\snafuarch is a complete ULP, CGRA-based system}
\snafuarch is a specific, complete system implementation that includes a CGRA generated by \snafuframe.
% % 
The CGRA is a 6$\times$6 mesh topology composed of PEs from \snafuframe's standard PE library.
%
\snafuarch integrates the CGRA fabric with a scalar core and 256\,KB of on-chip SRAM main memory.
%
The resulting system executes vectorized, RISC-V programs~\cite{riscv_2019}
with the generality of software and extremely low power consumption ($\approx$300\,\textmu W).  
% 
Compared to the \mbox{RISC-V} scalar core, \snafuarch uses $81\%$ less energy for equal work and is $9.9\times$ faster.
% 
Compared to \manic (a state-of-the-art general-purpose ULP design), \snafuarch uses $41\%$ less energy and is $4.4\times$ faster.
%
Compared to hand-coded ASICs, \snafuarch uses $2.6\times$ more energy and is $2.1\times$ slower.

\paragraph{Example of \snafu in action}
\autoref{fig:snafu:overview:execute} shows the workflow to take a simple vectorized kernel and execute it on an ULP CGRA generated by \snafuframe.
%
This kernel multiplies values at address {\tt \&a} by 5 for the elements where the mask {\tt m} is set,
  sums the result, and stores it to address {\tt \&c}.
% 
\snafuframe's compiler extracts the dataflow from the kernel source code and generates a bitstream to configure the CGRA fabric.
%
The scalar core configures the CGRA fabric and kicks off fabric execution using three new instructions ({\tt vcfg}, {\tt vtfr}, {\tt vfence}),
after which the CGRA runs autonomously in SIMD fashion over arbitrarily many input data values.
% 
The fabric executes the kernel using asynchronous dataflow firing:
\begin{compactitem}
\item[\circled{1}]
In the first timestep, the two memory PEs (that load {\tt a[0]} and {\tt m[0]}) are enabled and issue loads.
%
The rest of the fabric is idle because it has no valid input values.
\item[\circled{2}]
The load for {\tt a[0]} completes, but {\tt m[0]} cannot due to a bank conflict.
%
This causes a stall, which is handled transparently by \snafuframe's scheduling logic and bufferless NoC.
%
Meanwhile, the load of {\tt a[1]} begins.
%
\item[\circled{3}]
% 
As soon as the load for {\tt m[0]} completes, the multiply operation can fire because both of its inputs have arrived.
% 
But {\tt m[0] == 0}, meaning the multiply is disabled, so {\tt a[0]} passes through transparently.
%
The load of {\tt a[1]} completes, and loads for {\tt a[2]} and {\tt m[1]} begin.
%
\item[\circled{4}]
%
When the predicated multiply completes, its result is consumed by the fourth PE, which keeps a partial sum of the products.
%
The preceding PEs continue executing in pipelined fashion,
multiplying {\tt a[1]} $\times$ {\tt 5} (since {\tt m[1] == 1}) and loading {\tt a[3]} and {\tt m[2]}.
%
\item[\circled{5}]
%
Finally, a value arrives at the fifth PE, and is stored back to memory in {\tt c[0]}.
%
Execution continues in this fashion until all elements of {\tt a} and {\tt m} have been processed and a final result has been stored back to memory...
\end{compactitem}

\noindent
The next three sections describe \snafuframe.
% 
\autoref{snafuflexible} describes the \snafuframe ULP CGRA-generator.
% 
\autoref{snafuenergy} describes how \snafuframe minimizes energy.
% 
And \autoref{snafuarch} describes \snafuarch.

