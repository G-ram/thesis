\section{\snafuarch: A Complete ULP System w/ CGRA}
\label{snafu:arch}
 
\snafuarch is a complete ULP system that includes a CGRA fabric generated by \snafuframe
integrated with a scalar RISC-V core and memory.

\figSNAFUArch

\subsection{Architectural overview}
\autoref{fig:snafu:arch} shows an overview of the architecture of \snafuarch.
% 
There are three primary components: a \mbox{RISC-V} scalar core, a banked memory, and the \snafuframe fabric.
% 
The \snafu fabric is tightly coupled to the scalar core.
% 
It is a 6$\times$6 mesh possessing 12 memory PEs, 12 basic-ALU PEs, 8 scratchpad PEs, and 4 multiplier PEs.
% 
The RTL for the fabric is generated using \snafuframe and the mesh topology shown.
%
The memory PEs connect to the banked memory, while the scratchpad PEs each connect to 1\,KB outside the fabric.

The RISC-V scalar core implements the E, M, I, and C extensions and issues control signals to the \snafuframe fabric.
% 
The banked memory has eight 32\,KB memory banks (256\,KB total). 
% 
In total there are 15 ports to the banked memory: thirteen from the \snafuframe fabric and two from the scalar core.
% 
The twelve memory PEs account for the majority of the ports from the fabric.
% 
The final port from the fabric allows the \snafuframe configurator to load configuration bitstreams from memory.
% 
Each bank of the main memory can execute a single memory request at a time; its bank controller arbitrates requests using a round-robin policy to maintain fairness.

\begin{table}[b]
  \centering
  \footnotesize
  \begin{tabular}{lp{1.85in}}
    \toprule
    \bf Instruction & \bf Purpose \\
    \midrule
    {\tt vcfg <len> <addr>} & Load a new fabric configuration and set vector length. \\
    {\tt vtfr <val> <pe>} & Communicate scalar value to fabric. \\
    {\tt vfence} & Start fabric execution and wait. \\
    \bottomrule
  \end{tabular}
  \caption{New instructions to interface with CGRA.}
  \label{tab:snafu:extensions}
\end{table}
\subsection{Example of \snafuarch in action}

\snafuarch adds three instructions to the scalar core to interface with the CGRA fabric,
summarized in \autoref{tab:snafu:extensions}.
We explain how they work through the following example.

The \snafuframe fabric operates in three states: idle, configuration, and execution.
% 
During the idle phase the scalar core is running and the fabric is not.
% 
When the scalar core reaches a {\tt vcfg} instruction, the fabric transitions to the configuration state.
% 
The scalar core passes a vector length and a bitstream address (from the register file) to the fabric configurator (see \autoref{fig:snafu:arch}).
% 
The configurator checks to see if this configuration is still in the fabric's configuration cache (\autoref{snafu:flexible:config}).
%
If it is, the configurator broadcasts a control signal to all PEs and routers to load the cached configuration;
otherwise, it loads the configuration header from memory.
% 
The header tells the configurator which routers and which PEs are active in the configuration.
% 
Then the configurator issues a series of loads to read in configuration bits for the enabled PEs and routers.
 
Once this has completed, the configurator stalls until the scalar core either reaches a {\tt vtfr} instruction or a {\tt vfence} instruction.
% 
{\tt vtfr} lets the scalar core pass a register value to the fabric configurator, which then passes that value to a specific PE (encoded in the instruction).
% 
This allows PEs to be further parameterized at runtime from the scalar core. %  by code running on the scalar core.
% 
{\tt vfence} indicates that configuration is done, so the scalar core stalls and the fabric transitions to execution.
% 
Execution proceeds until all PEs signal that they have completed their work (\autoref{snafu:flexible:fu}).
%
Finally, the scalar core resumes execution from the {\tt vfence}, and the fabric transitions back into the idle state.
